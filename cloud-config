#!/bin/bash

set -euo pipefail
pushd "${BASH_SOURCE[0]%/*}" &>/dev/null && 
  trap 'popd &>/dev/null' EXIT

# source libraries
source libs/git.sh

# set environment variables
: "${CLOUD_PATH_CONFIG:="$(git::top)/cloud-init"}"
: "${CLOUD_PATH_WRITE_FILES:="${CLOUD_PATH_CONFIG}/write_files"}"
: "${CLOUD_USER:="user"}"
: "${CLOUD_GROUP:="root"}"
: "${CLOUD_SSH_PUB:="${HOME}/.ssh/id_rsa.pub"}"

# readout local pub key
ssh::pub() {
  # read out pub key without hostname
  cut -d' ' -f-2 "${CLOUD_SSH_PUB}"
}

# generates all files base64 encoded
cloud-config::write_files() {
  local -r path_files="${CLOUD_PATH_WRITE_FILES}"

  # go thorugh ./write_files folder
  for file in $(find "${path_files}" -type f -not -name '*.stat'); do
    local stat="${file}.stat"
    local content=""
    local path="${file:${#path_files}}"
    # todo: sadly files are written before user is create and without user write_files failes
    local owner="${CLOUD_USER}:${CLOUD_GROUP}"
    # local owner="root:root"
    local permissions='0655'

    [ ! -f "${stat}" ] || {
      ! grep -Eq '^owner: .+$' "${stat}" ||
        owner="$(sed -En 's/^owner: (.+)$/\1/p' "${stat}")"
      ! grep -Eq '^permissions: .+$' "${stat}" ||
        permissions="$(sed -En 's/^permissions: (.+)$/\1/p' "${stat}")"
      ! grep -q '^execute: true$' "${stat}" ||
        content="$(bash "${file}")"
      ! grep -q '^envsubst: true$' "${stat}" ||
        content="$(envsubst <"${file}")"
    }

    cat <<EOF
- encoding: b64
  content: $(echo "${content:-"$(cat "${file}")"}" | base64 -w0)
  path: "${path}"
  owner: ${owner}
  permissions: '${permissions}'
EOF
  done
}

# generate runcmd commands
cloud-config::runcmd() {
  local -r path_files="${CLOUD_PATH_WRITE_FILES}"

  # go through *.stat files
  find "${path_files}" -type f -name '*.stat' -exec bash -c '
    ! grep -q "^runcmd: true$" "${1}" ||
      echo "- ${1:'${#path_files}':-5}"
  ' _ {} \;
}

# generate packages list
cloud-config::packages() {
  sed -e 's/^/- /g' "${CLOUD_PATH_CONFIG}/packages"
}

# generates nameserver list
cloud-config::nameservers() {
  sed -e 's/^/    - /g' "${CLOUD_PATH_CONFIG}/nameservers"
}

# print cloud-config
cloud-config::generate() {
  cat <<EOF
#cloud-config

package_update: true
package_upgrade: true
package_reboot_if_required: true

disable_root: 1
ssh_pwauth:   0

mounts:
# One of the first things you should do is secure the shared memory used on the system.
- [ tmpfs, /run/shm, "tmpfs", "ro,noexec,nosuid", "0", "0" ]

manage-resolv-conf: true
resolv_conf:
  nameservers:
$(cloud-config::nameservers)

write_files:
$(cloud-config::write_files)

users:
- name: "${CLOUD_USER}"
  lock_passwd: true
  shell: /bin/bash
  ssh-authorized-keys:
    - "$(ssh::pub)"
  groups:
    - docker
  sudo:
    - ALL=(ALL) NOPASSWD:ALL

packages:
$(cloud-config::packages)

runcmd:
# https://bugs.launchpad.net/cloud-init/+bug/1486113/comments/12
- cloud-init single --name write_files --frequency once
# run the rest not as root
- su - "${CLOUD_USER}"
$(cloud-config::runcmd)

final_message: "The system is finally up, after \$UPTIME seconds"
EOF
}

# will be executed if script is called directly
cloud-config() {
  [ -d "${CLOUD_PATH_CONFIG}" ] || {
    echo "ðŸ® cloud-init path does not exists: ${CLOUD_PATH_CONFIG}"
    return 1
  }

  cloud-config::generate
}

# only execute if called directly
[[ "${0}" != "${BASH_SOURCE[0]}" ]] || cloud-config "${@}"
